_This is my summary of the  Kotlin for Android Developers by Antonio Leiva. I use it while learning and as quick reference. It is not intended to be an standalone substitution of the book so if you really want to learn the concepts here presented, buy and read the book and use this repository as a reference and guide._

[https://antonioleiva.com/kotlin-android-developers-book/](https://antonioleiva.com/kotlin-android-developers-book/)

# 4 Classes and functions

## 4.1 Class declaration
```kotlin

	class MainActivity {...}
```
 Only 1 default constructor


```kotlin

	class Person(name: String, surname: String)
```

Constructor body can be in the `init`

```kotlin

	class Person(name: String, surname: String) {
        init {...} 
	}
```

## 4.2 Class inheritance

Class are as default `final`
Can only be extended if it's explicitly declared as `open` or `abstract`

Note that when using the single constructor nomenclature, we need to specify the parameters we're using for the parent constructor. That's the substitution to super() call in Java.

```kotlin
	
	open class Animal(name: String)
	class Person(name: String, surname: String) : Animal(name)
```

## 4.3 Functions

```kotlin
	
	fun onCreate(savedInstanceState: Bundle?) {...}
```
```kotlin
	
	fun add(x: Int, y: Int) : Int {
		return x + y
	}

	//or

	fun add(x:Int,y:Int):Int=x+y
```

## 4.4 Constructor and functions parameters

First  name then type.
```kotlin

	fun add(x: Int, y: Int) : Int { 
		return x + y
	}
```
Default values.

```kotlin
	
	fun toast(message: String, length: Int = Toast.LENGTH_SHORT) {
    	 Toast.makeText(this, message, length).show()
	}

```
# 7 Anko and Extension Functions
## 7.2 Anko
```kotlin 

	import org.jetbrains.anko.find
	...
	val forecastList: RecyclerView = find(R.id.forecast_list)
```
## 7.3 Extension functions
        

```kotlin 
	
	fun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) {
    	 Toast.makeText(this, message, duration).show()
    }
```

```kotlin
	
	public var TextView.text: CharSequence
    	get() = getText()
    	set(v) = setText(v)
```
# 8 Retrieving data from API

```kotlin

	public class Request(val url: String) {

	    public fun run() {
	        val forecastJsonStr = URL(url).readText()
	        Log.d(javaClass.simpleName, forecastJsonStr)
	    }
	}
```
## 8.2 Performing the request out of the main thread

If it's used by an Activity, the `uiThread` code won't be executed if `activity.isFinishing()` returns true, and it won't crash if the activity is no longer valid.

```kotlin
	
	async {
	     Request(url).run()
	     uiThread { 
	     	longToast("Request performed") 
	     }
	}
``` 

Custom executor

```kotlin
	
	val executor = Executors.newScheduledThreadPool(4)
		async(executor) {...}
	}
```

`async` returns a java Future, in case you want to work with futures. And if you need it to return a future with a result, you can use `asyncResult`.

# 9 Data Classes

```kotlin

	data class Forecast(val date: Date, val temperature: Float, val details: String)
```

* equals()
* hashCode()
* copy()

```kotlin
	
	val f1 = Forecast(Date(), 27.5f, "Shiny day")
	val f2 = f1.copy(temperature = 30f)
```

## 9.2 Mapping

```kotlin

	val f1 = Forecast(Date(), 27.5f, "Shiny day")
	val (date, temperature, details) = f1
```

```kotlin

	for ((key, value) in map) {
		Log.d("map", "key:$key, value:$value")
	}
```

# 10 Parsing data
## Companion objects
If we need some static properties, constants or functions in a class, we can use a companion object. This object will be shared among all instances of the class, the same as a static field or method would do in Java.

```kotlin

	public class ForecastRequest(val zipCode: String) {
	    companion object {
	        private val APP_ID = "15646a06818f61f7b8d7823ca833e1ce"
	        private val URL = "http://api.openweathermap.org/data/2.5/" +
	                "forecast/daily?mode=json&units=metric&cnt=7"
	        private val COMPLETE_URL = "$URL&APPID=$APP_ID&q="
	    }

	    public fun execute(): ForecastResult {
	        val forecastJsonStr = URL(COMPLETE_URL + zipCode).readText()
	        return Gson().fromJson(forecastJsonStr, ForecastResult::class.java)
		} 
	}
```
## Domain Layer
This layer will basically implement a set of Commands in charge of performing the tasks in the app.

```kotlin

	public interface Command<T> {
    	fun execute(): T
	}
```

```kotlin

	public class RequestForecastCommand(val zipCode: String) : Command<ForecastList> {
	    override fun execute(): ForecastList {
	        val forecastRequest = ForecastRequest(zipCode)
	        return ForecastDataMapper().convertFromDataModel(forecastRequest.execute())
	    }
	}
```

DataMapper

```kotlin

	import com.antonioleiva.weatherapp.data.ForecastResult
	import com.antonioleiva.weatherapp.domain.model.Forecast as ModelForecast

	private fun convertForecastListToDomain(list: List<Forecast>):
            List<ModelForecast> {
        return list.map { convertForecastItemToDomain(it) }
    }
```
Command

```kotlin

	 public class RequestForecastCommand(val zipCode: String) : Command<ForecastList> {
		override fun execute(): ForecastList {
	    	val forecastRequest = ForecastRequest(zipCode)
	    	return ForecastDataMapper().convertFromDataModel(
	            forecastRequest.execute())
	        }
	    }
```

With function

`with` receives an object and an extension function as parameters, and makes the object execute the function. Code inside the brackets acts as an extension function of the object we specify in the first parameter.

```kotlin
	
	override fun onBindViewHolder(holder: ForecastListAdapter.ViewHolder, position: Int) {
        with(weekForecast.dailyForecast[position]) {
            holder.textView.text = "$date - $description - $high/$low"
		}
	}
```

# 11 Operator overloading

```kotlin

	//From
	data class ForecastList(val city: String, val country: String, val dailyForecast:List<Forecast>)
	
	// To
	data class ForecastList(val city: String, val country: String, val dailyForecast: List<Forecast>) {
	    operator fun get(position: Int): Forecast = dailyForecast[position]
	    fun size(): Int = dailyForecast.size
	}

```

```kotlin

	///From
	with(weekForecast.dailyForecast[position]) {...
	override fun getItemCount(): Int = weekForecast.dailyForecast.size


	//To
	with(weekForecast[position]) {
	override fun getItemCount(): Int = weekForecast.size()
```

## 11.3 Operators in extension functions

```kotlin

	operator fun ViewGroup.get(position: Int): View = getChildAt(position)

	val container: ViewGroup = find(R.id.container)
	val view = container[2]
```	

# 12 Clickables

Create onClick.
```kotlin
 	
	public interface OnItemClickListener {
	        operator fun invoke(forecast: Forecast)
	    }
```
`invoke` method can be omitted 

```kotlin

	itemClick.invoke(forecast)
	itemClick(forecast)

```

Call onClick.

```kotlin

	forecastList.adapter = 
		ForecastListAdapter(
			result,
			object : ForecastListAdapter.OnItemClickListener{
    	    	override fun invoke(forecast: Forecast) {
        	    	toast(forecast.date)
        		}
    		}
    	)
```




Implement onClick

```kotlin
	
	public class ForecastListAdapter(	
			val weekForecast: ForecastList,
            val itemClick: ForecastListAdapter.OnItemClickListener
            ): RecyclerView.Adapter<ForecastListAdapter.ViewHolder>() {

	    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
	        val view = parent.ctx.layoutInflater.inflate(R.layout.item_forecast, parent, false)
	        return ViewHolder(view, itemClick)
	    }

	    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
	        holder.bindForecast(weekForecast[position])
	    }

	    override fun getItemCount(): Int = weekForecast.size()

	    class ViewHolder(view: View, val itemClick: OnItemClickListener) : RecyclerView.ViewHolder(view) {

	        private val iconView: ImageView
	        private val dateView: TextView
	        private val descriptionView: TextView
	        private val maxTemperatureView: TextView
	        private val minTemperatureView: TextView

	        init {
	            iconView = view.find(R.id.icon)
	            dateView = view.find(R.id.date)
	            descriptionView = view.find(R.id.description)
	            maxTemperatureView = view.find(R.id.maxTemperature)
	            minTemperatureView = view.find(R.id.minTemperature)
	        }

	        fun bindForecast(forecast: Forecast) {
	            with(forecast) {
	                Picasso.with(itemView.ctx).load(iconUrl).into(iconView)
	                dateView.text = date
	                descriptionView.text = description
	                maxTemperatureView.text = "${high.toString()}ยบ"
	                minTemperatureView.text = "${low.toString()}ยบ"
	                itemView.onClick { itemClick(forecast) }
	            }
	        }
	    }

	    public interface OnItemClickListener {
	        operator fun invoke(forecast: Forecast)
	    }
	}
	
```

# 13 Lambdas
## 13.1 Simplifying setOnClickListener()

```kotlin

	view.setOnClickListener(object : OnClickListener {
	     override fun onClick(v: View) {
	         toast("Click")
	     }
     })
```
Function that receives an interface with a single function can be substituted by the function.
```kotlin

	fun setOnClickListener(listener: (View) -> Unit)

	view.setOnClickListener({ view -> toast("Click")})
```

We can even get rid of the left part if the parameters are not being used:
```kotlin

	view.setOnClickListener({ toast("Click") })
```

If the function is the last one in the parameters of the function, we can move it out of the parentheses:

```kotlin

	view.setOnClickListener() { toast("Click") }
```

And, finally, if the function is the only parameter, we can get rid of the parentheses:
```kotlin

	view.setOnClickListener { toast("Click") }
```

Anko version
```kotlin

	view.onClick { toast("Click") }
```

## 13.2 Click listener for ForecastListAdapter

```kotlin
	
	public class ForecastListAdapter(
				val weekForecast: ForecastList,
				val itemClick: (Forecast) -> Unit
			)

	class ViewHolder(view: View, val itemClick: (Forecast) -> Unit)		
```

Call it from the MainActivity
```kotlin

	val adapter = ForecastListAdapter(result) { forecast -> toast(forecast.date) }
```


In functions that only need one parameter, we can make use of the `it` reference.
```kotlin
	
	val adapter = ForecastListAdapter(result) { toast(it.date) }
```	

## 13.3 Extending the language

This function gets an object of type T and a function that will be used as an extension function. The implementation just takes the object and lets it execute the function.

 As the second parameter of the function is another function, it can be brought out of the parentheses, so we can create a block of code where we can use this and the public properties and functions of the object directly:

```kotlin
	
	inline fun <T> with(t: T, body: T.() -> Unit) { t.body() }
```	

An **inline function** will be substituted by its code during compilation, instead of really calling to a function

```kotlin
	
	inline fun supportsLollipop(code: () -> Unit) {
    	if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        	code()
     	}
     
     ...
     	
    supportsLollipop {
		window.setStatusBarColor(Color.BLACK)
	}

```
# 14 Visibility Modifiers
The default modifier in kotlin is `public`

By default, all constructors are `public`

```kotlin

	class C private constructor(a: Int) { ... }
```

# 15 Kotlin Android Extensions

```kotlin
	
	import kotlinx.android.synthetic.view_item.titleView.*
	...
	titleView.textView.text = "Hello"
```
# 16 Application Singleton and Delegated Properties
## 16.2 Delegated Properties

```kotlin

	 class Delegate<T> : ReadWriteProperty<Any?, T> {
	  	fun getValue(thisRef: Any?, property: KProperty<*>): T {
	    	return ...
	  	}
	 
	  	fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
	    	...
		}
	}


	class Example {
		 var p: String by Delegate() 
	}
``` 
## 16.3 Standard Delegates
**Lazy:** It takes a lambda that is executed the first time getValue is called, so the initialisation of the property is delayed up to that moment. 

**Observable:**  Execute the lambda expression we specify, every time the set function is called.

**Vetoable:**  Lets you decide whether the value must be saved or not.

**lateinit:** Identifies that the property should have a non-nullable value, but its assignment will be delayed. If the value is requested before it is assigned, it will throw an exception that clearly identifies the property being accessed.

**Values from a map:** Creates an instance of an object from a dynamic map.

## 16.4 Custom delegate
```kotlin

	// `object` keyword is used to define singletons.Cannot assign to a variable, but can refer to it by its name.
	object DelegatesExt { 
	    fun <T> notNullSingleValue():
	            ReadWriteProperty<Any?, T> = NotNullSingleValueVar()
	}

	private class NotNullSingleValueVar<T>() : ReadWriteProperty<Any?, T> {

	    private var value: T? = null

	    override fun getValue(thisRef: Any?, property: KProperty<*>): T {
	        return value ?: throw IllegalStateException("${property.name} not initialized")
	    }

	    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
	        this.value = if (this.value == null) value
	        else throw IllegalStateException("${property.name} already initialized")
	    }
	}
```

`instance` will have a reference to the Application, but because we don't know when it is going to be set, we delegate its assignment to the singleton (DelegatesExt) function notNullSingleValue(), that will return its value if it is not null, ioc an exception will be thrown. Initialisation to `instance` will only be performed once.

```kotlin

	class App : Application() {
    	
    	companion object {
        	var instance: App by DelegatesExt.notNullSingleValue()
    	}

    	override fun onCreate() {
        	super.onCreate()
        	instance = this
    	}
	}
```
# 17 Creating an SQLiteOpenHelper

```kotlin

	forecastDbHelper.use {
		...
	}
```
```kotlin

	public fun <T> use(f: SQLiteDatabase.() -> T): T {
	     try {
	         return openDatabase().f()
	     } finally {
	         closeDatabase()
	     }
	}
```

```kotlin

	class ForecastDbHelper(ctx: Context = App.instance) : ManagedSQLiteOpenHelper(ctx,
        ForecastDbHelper.DB_NAME, null, ForecastDbHelper.DB_VERSION) {

	    companion object {
	        val DB_NAME = "forecast.db"
	        val DB_VERSION = 1
	        val instance: ForecastDbHelper by lazy { ForecastDbHelper() }
	    }

	    override fun onCreate(db: SQLiteDatabase) {
	        db.createTable(CityForecastTable.NAME, true,
	                CityForecastTable.ID to INTEGER + PRIMARY_KEY,
	                CityForecastTable.CITY to TEXT,
	                CityForecastTable.COUNTRY to TEXT)

	        db.createTable(DayForecastTable.NAME, true,
	                DayForecastTable.ID to INTEGER + PRIMARY_KEY + AUTOINCREMENT,
	                DayForecastTable.DATE to INTEGER,
	                DayForecastTable.DESCRIPTION to TEXT,
	                DayForecastTable.HIGH to INTEGER,
	                DayForecastTable.LOW to INTEGER,
	                DayForecastTable.ICON_URL to TEXT,
	                DayForecastTable.CITY_ID to INTEGER)
	    }

	    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
	        db.dropTable(CityForecastTable.NAME, true)
	        db.dropTable(DayForecastTable.NAME, true)
	        onCreate(db)
	    }
	}

```
## 17.4 Dependency injection
Simple way. Use default values

```kotlin

	class ForecastDbHelper(ctx: Context = App.instance) :
        ManagedSQLiteOpenHelper(ctx, ForecastDbHelper.DB_NAME, null,
        ForecastDbHelper.DB_VERSION) {
        ...
    }

    ...	

    val dbHelper1 = ForecastDbHelper() // It will use App.instance
	val dbHelper2 = ForecastDbHelper(mockedContext) // For tests, for example

```

# 18 Collections and functional operations

* **Iterable**: The parent class. Any classes that inherit from this interface represent a sequence of elements we can iterate over.
* **MutableIterable**: Iterables that support removing items during iteration.
* **Collection**: This class represents a generic collection of elements. We get access to functions that return the size of the collection, whether the collection is empty, contains an item or a set of items. All the methods for this kind of collections are only to request data, because
collections are immutable.
* **MutableCollection**: a Collection that supports adding and removing elements. It provides
extra functions such as add, remove or clear among others.
* **List**: Probably the most popular collection type. It represents a generic ordered collection of
elements. As itโs ordered, we can request an item by its position, using the get function.
* **MutableList**: a List that supports adding and removing elements.
* **Set**: an unordered collection of elements that doesnโt support duplicate elements.
* **MutableSet**: a Set that supports adding and removing elements.
* **Map**: a collection of key-value pairs. The keys in a map are unique, which means we cannot
have two pairs with the same key in a map.
* **MutableMap**: a Map that supports adding and removing elements.

## 18.1 Aggregate operations

### **any**
Returns _true_ if at least one element matches the given predicate.
```kotlin

	val list = listOf(1, 2, 3, 4, 5, 6)
	assertTrue(list.any { it % 2 == 0 })
	assertFalse(list.any { it > 10 })
```

### **all**
Returns _true_ if all the elements match the given predicate.

`assertTrue(list.all { it < 10 })`

`assertFalse(list.all { it % 2 == 0 })`

### **count**
Returns the number of elements matching the given predicate.

`assertEquals(3, list.count { it % 2 == 0 })`

### **fold**
Accumulates the value starting with an initial value and applying an operation from the first to the last element in a collection.

`assertEquals(25, list.fold(4) { total, next -> total + next })`

### **foldRight**
Same as fold, but it goes from the last element to first.

`assertEquals(25, list.foldRight(4) { total, next -> total + next })`

### **forEach**
Performs the given operation to each element.

`list.forEach { println(it) }`

### **forEachIndexed**

Same as forEach, though we also get the index of the element.

`list.forEachIndexed { index, value  -> println("position $index contains a $value") }`

### **max**
Returns the largest element or null if there are no elements.

`assertEquals(6, list.max())`

### **maxBy**
Returns the first element yielding the largest value of the given function or null if there are no elements.

// The element whose negative is greater

`assertEquals(1, list.maxBy { -it })`

### **min**
Returns the smallest element or null if there are no elements.

`assertEquals(1, list.min())`

### **minBy**
Returns the first element yielding the smallest value of the given function or null if there are no elements.

// The element whose negative is smaller

`assertEquals(6, list.minBy { -it })`

### **none**
Returns true if no elements match the given predicate.

// No elements are divisible by 7

`assertTrue(list.none { it % 7 == 0 })`

### **reduce**
Same as fold, but it doesn't use an initial value. It accumulates the value applying an operation from the first to the last element in a collection.

`assertEquals(21, list.reduce { total, next -> total + next })`

### **reduceRight**

Same as reduce, but it goes from the last element to first.

`assertEquals(21, list.reduceRight { total, next -> total + next })`

### **sumBy**
Returns the sum of all values produced by the transform function from the elements in the collection.

`assertEquals(3, list.sumBy { it % 2 })`



## 18.2 Filtering operations
### **drop**
Returns a list containing all elements except first n elements.

`assertEquals(listOf(5, 6), list.drop(4))`

### **dropWhile**
Returns a list containing all elements except first elements that satisfy the given predicate.

`assertEquals(listOf(3, 4, 5, 6), list.dropWhile { it < 3 })`

### **dropLastWhile**
Returns a list containing all elements except last elements that satisfy the given predicate.

`assertEquals(listOf(1, 2, 3, 4), list.dropLastWhile { it > 4 })`

### **filter**
Returns a list containing all elements matching the given predicate.

`assertEquals(listOf(2, 4, 6), list.filter { it % 2 == 0 })`

### **filterNot**
Returns a list containing all elements not matching the given predicate.

`assertEquals(listOf(1, 3, 5), list.filterNot { it % 2 == 0 })`

### **filterNotNull**
Returns a list containing all elements that are not null.

`assertEquals(listOf(1, 2, 3, 4), listWithNull.filterNotNull())`

### **slice**
Returns a list containing elements at specified indices.

`assertEquals(listOf(2, 4, 5), list.slice(listOf(1, 3, 4)))`

### **take**
Returns a list containing first n elements.

`assertEquals(listOf(1, 2), list.take(2))`

### **takeLast**
Returns a list containing last n elements.

`assertEquals(listOf(5, 6), list.takeLast(2))`

### **takeWhile**
Returns a list containing first elements satisfying the given predicate.

`assertEquals(listOf(1, 2), list.takeWhile { it < 3 })`

## 18.3 Mapping operations

### **flatMap**
Iterates over the elements creating a new collection for each one, and finally flattens all the collections into a unique list containing all the elements.

`assertEquals(listOf(1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7), list.flatMap { listOf(it, it + 1) })`

### **groupBy**
Returns a map of the elements in original collection grouped by the result of given function

`assertEquals(mapOf("odd" to listOf(1, 3, 5), "even" to listOf(2, 4, 6)), list.groupBy { if (it % 2 == 0) "even" else "odd" })`

### **map**
Returns a list containing the results of applying the given transform function to each element of the original collection.

`assertEquals(listOf(2, 4, 6, 8, 10, 12), list.map { it * 2 })`

### **mapIndexed**
Returns a list containing the results of applying the given transform function to each element and its index of the original collection.

`assertEquals(listOf (0, 2, 6, 12, 20, 30), list.mapIndexed { index, it -> index * it })`

### **mapNotNull**
Returns a list containing the results of applying the given transform function to each non-null element of the original collection.

`assertEquals(listOf(2, 4, 6, 8), listWithNull.mapNotNull { it * 2 })`


## 18.4 Elements operations
### **contains**
Returns true if the element is found in the collection.

`assertTrue(list.contains(2))`

### **elementAt**
Returns an element at the given index or throws an IndexOutOfBoundsException if the index is out of bounds of this collection.

`assertEquals(2, list.elementAt(1))`

### **elementAtOrElse**
Returns an element at the given index or the result of calling the default function if the index is out of bounds of this collection.

`assertEquals(20, list.elementAtOrElse(10, { 2 * it }))`

### **elementAtOrNull**
Returns an element at the given index or null if the index is out of bounds of this collection.

`assertNull(list.elementAtOrNull(10))`

### **first**
Returns the first element matching the given predicate

`assertEquals(2, list.first { it % 2 == 0 })`

### **firstOrNull**
Returns the first element matching the given predicate, or null if no element was found.

`assertNull(list.firstOrNull { it % 7 == 0 })`

### **indexOf**
Returns the first index of element, or -1 if the collection does not contain element.

`assertEquals(3, list.indexOf(4))`

### **indexOfFirst**
Returns index of the first element matching the given predicate, or -1 if the collection does not contain such element.

`assertEquals(1, list.indexOfFirst { it % 2 == 0 })`

### **indexOfLast**
Returns index of the last element matching the given predicate, or -1 if the collection does not contain such element.

`assertEquals(5, list.indexOfLast { it % 2 == 0 })`

### **last**
Returns the last element matching the given predicate.

`assertEquals(6, list.last { it % 2 == 0 })`

### **lastIndexOf**
Returns last index of element, or -1 if the collection does not contain an element.

```kotlin

	val listRepeated = listOf(2, 2, 3, 4, 5, 5, 6)
	assertEquals(5, listRepeated.lastIndexOf(5))
```
### **lastOrNull**
Returns the last element matching the given predicate, or null if no such element was found.

```kotlin

	val list = listOf(1, 2, 3, 4, 5, 6)
	assertNull(list.lastOrNull { it % 7 == 0 })
```

### **single**
Returns the single element matching the given predicate, or throws exception if there is no or more than one matching element.

`assertEquals(5, list.single { it % 5 == 0 })`

### **singleOrNull**
Returns the single element matching the given predicate, or null if element was not found or more than one element was found.

`assertNull(list.singleOrNull { it % 7 == 0 })`

## 18.5 Generation operations
### **merge**
Returns a list of values built from elements of both collections with same indexes using the provided transform function. The list has the length of shortest collection.

```kotlin

	val list = listOf(1, 2, 3, 4, 5, 6)
	val listRepeated = listOf(2, 2, 3, 4, 5, 5, 6)
	assertEquals(listOf(3, 4, 6, 8, 10, 11), list.merge(listRepeated) { it1, it2 ->  it1 + it2 })
```

### **partition**
Splits original collection into pair of collections, where the first collection contains elements for which the predicate returned true, while the second collection contains elements for which the predicate returned false.

`assertEquals(Pair(listOf(2, 4, 6), listOf(1, 3, 5)), list.partition { it % 2 == 0 })`

### **plus**
Returns a list containing all elements of the original collection and then all elements of the given collection. Because of the name of the function, we can use the โ+โ operator with it.

`assertEquals(listOf(1, 2, 3, 4, 5, 6, 7, 8), list + listOf(7, 8))`

### **zip**
Returns a list of pairs built from the elements of both collections with the same indexes. The list has the length of the shortest collection.

`assertEquals(listOf(Pair(1, 7), Pair(2, 8)), list.zip(listOf(7, 8)))`

### **unzip**
Generates a Pair of Lists from a List of Pairs

`assertEquals(Pair(listOf(5, 6), listOf(7, 8)), listOf(Pair(5, 7), Pair(6, 8)).unzip())`

## 18.6 Ordering operations
### **reverse**
Returns a list with elements in reversed order.
```kotlin

	val unsortedList = listOf(3, 2, 7, 5)
	assertEquals(listOf(5, 7, 2, 3), unsortedList.reverse())
```	

### **sort**
Returns a sorted list of all elements.

`assertEquals(listOf(2, 3, 5, 7), unsortedList.sort())`

### **sortBy**
Returns a list of all elements, sorted by the specified comparator.

`assertEquals(listOf(3, 7, 2, 5), unsortedList.sortBy { it % 3 })`

### **sortDescending**
Returns a sorted list of all elements, in descending order.

`assertEquals(listOf(7, 5, 3, 2), unsortedList.sortDescending())`

### **sortDescendingBy**
Returns a sorted list of all elements, in descending order by the results of the specified order function.

`assertEquals(listOf(2, 5, 7, 3), unsortedList.sortDescendingBy { it % 3 })`

## 19 DataBase

**Model Class for the database.**

Use of delegate `by map` to automatically convert from map to database model.

```kotlin

	class CityForecast(val map: MutableMap<String, Any?>, val dailyForecast: List<DayForecast>) {
	    var _id: Long by map
	    var city: String by map
	    var country: String by map

	    //Second constructor with an empty Map and the data as parameters.
	    constructor(id: Long, city: String, country: String, dailyForecast: List<DayForecast>) 
	    	: this(HashMap(), dailyForecast) { // Here is the return statement. the super method (the main constructor) with an new empty HashMap, and the dailyForecast.
		        this._id = id
		        this.city = city
		        this.country = country
		    }
	}
```

**Writing and requesting data**
We use a DbHelper and a data mapper.

```kotlin

	class ForecastDb(val forecastDbHelper: ForecastDbHelper = ForecastDbHelper.instance,
                 val dataMapper: DbDataMapper = DbDataMapper()) {

```
We call the `use` function to get the data from the database.

**Request**
```kotlin

	fun requestForecastByZipCode(zipCode: Long, date: Long) = forecastDbHelper.use {

        val dailyRequest = "${DayForecastTable.CITY_ID} = ? AND ${DayForecastTable.DATE} >= ?"
        val dailyForecast = select(DayForecastTable.NAME)
                .whereSimple(dailyRequest, zipCode.toString(), date.toString())
                .parseList { DayForecast(HashMap(it)) }

        val city = select(CityForecastTable.NAME)
                .whereSimple("${CityForecastTable.ID} = ?", zipCode.toString())
                .parseOpt { CityForecast(HashMap(it), dailyForecast) }

        if (city != null) dataMapper.convertToDomain(city) else null
    }
```
**Save**

```kotlin

	fun saveForecast(forecast: ForecastList) = forecastDbHelper.use {

        clear(CityForecastTable.NAME)
        clear(DayForecastTable.NAME)

        with(dataMapper.convertFromDomain(forecast)) {
            insert(CityForecastTable.NAME, *map.toVarargArray())
            dailyForecast.forEach { insert(DayForecastTable.NAME, *it.map.toVarargArray()) }
        }
    }
```

The _RowParser_ relies on the order of the columns, while the _MapRowParser_ uses the name of the column as the key of the map.

##  20 Null safety in Kotlin

```kotlin

	val a : Int? = null
	// can not be used. Not compile.
	a.toString() 

	//Smart Cast: now is a non nullable type
	if (a != null) 
		a.toString() // Compile

	// Safe call operator
	a?.toString()	 // If `a` is null it won't do nothing.

	//Alternative values. Elvis operator.
	val myString = a?.toString ?: ""

	// Also works
	val myString = a?.toString() ?: return false
	val myString = a?.toString() ?: throw IllegalStateException()

	// Force to be not nullabe "CAREFULL"
	a!!.toString()
```

Objects coming from Java will be marked with `!`. The developer should choose how to behave (Nullable or not Nullable)

We decide
```kotlin
	
	override fun onCreate(savedInstanceState: Bundle)  { ... }
	 // This is the correct one. We know that 'Bundle' could be null.
	override fun onCreate(savedInstanceState: Bundle?) { ... }
	

```


_@Nullable_ and _@NotNull_ Android annotations can help. Jetbrains also has its own _@Nullable_ annotation.

##  21. Business Logic

Create an interface that the data providers must implement.
```kotlin
	
	interface ForecastDataSource {
    	fun requestForecastByZipCode(zipCode: Long, date: Long): ForecastList?
    }
``` 

The provider iterate through the data sources until it gets some data. Repository Pattern

```kotlin

	class ForecastProvider(val sources: List<ForecastDataSource> = ForecastProvider.SOURCES) {

	    companion object {
	        val DAY_IN_MILLIS = 1000 * 60 * 60 * 24;
	        val SOURCES = listOf(ForecastDb(), ForecastServer())
	    }

	    fun requestByZipCode(zipCode: Long, days: Int): ForecastList
	            = sources.firstResult { requestSource(it, days, zipCode) }

	    private fun requestSource(source: ForecastDataSource, days: Int, zipCode: Long): ForecastList? {
	        val res = source.requestForecastByZipCode(zipCode, todayTimeSpan())
	        return if (res != null && res.size() >= days) res else null
	    }

	    private fun todayTimeSpan() = System.currentTimeMillis() / DAY_IN_MILLIS * DAY_IN_MILLIS
	}
```

##  22. Flow control and ranges

**if**
The if expression always returns a value. Unit.
```kotlin
	
	val z = if (condition) x else y
```	

**when**
```kotlin
	
	val result = when (x) {
	     0, 1 -> "binary"
	     else -> "error"
	}
```
Casting
```	kotlin

	when(view) {
		is TextView -> view.setText("I'm a TextView")
		is EditText -> toast("EditText value: ${view.getText()}")
		is ViewGroup -> toast("Number of children: ${view.getChildCount()} ")
		else -> view.visibility = View.GONE
	}
```
Ranges
```kotlin

	val cost = when(x) {
		in 1..10 -> "cheap"
		in 10..100 -> "regular"
		in 100..1000 -> "expensive"
		in specialValues -> "special value!"
		else -> "not rated"
	}
 	
```
Mixed
```kotlin

	val res = when {
	    x in 1..10 -> "cheap"
	    s.contains("hello") -> "it's a welcome!"
	    v is ViewGroup -> "child count: ${v.getChildCount()}"
	    else -> "" 
	}
```

**for** 	

```kotlin

	for (item in collection) {
		print(item)
	}
```
Ranges
```kotlin
	
	for (index in 0..viewGroup.getChildCount() - 1) {
		val view = viewGroup.getChildAt(index)
		view.visibility = View.VISIBLE
	}
```
Indices in lists and arrays
```kotlin

	for (i in array.indices)
		print(array[i])

```

**while**

```kotlin

	while (x > 0) {
		x--
	}
```
**do while**
```kotlin	

	do {
		val y = retrieveData()
	} while (y != null) // y is visible here!
```

**Ranges**

```kotlin

	if (i in 0..10)
    	println(i)
```

Ranges are incremental by default
```kotlin

	for (i in 10..0)
	     println(i)//Would do nothing
```	     

_downTo_
```kotlin
	
	for (i in 10 downTo 0)
	     println(i)
```

_step_
```kotlin

	for (i in 1..4 step 2) println(i) 
	for (i in 4 downTo 1 step 2) println(i)
```

_until_
```kotlin

	for (i in 0 until 4) println(i)// 0 until 4 == 0..3
```

Cleaner: `(i in 0 until list.size)` instead of  `(i in 0..list.size - 1)`

Creative samples
```kotlin

	val views = (0..viewGroup.childCount - 1).map { viewGroup.getChildAt(it) }
```


##  23 _reified_
As you may know, when we create a generic method in Java, there is no way to get the class from the generic type. A popular workaround is to pass the class as a parameter. In Kotlin, an inline function can be reified, which means we can get and use the class of the generic type inside the function. In this case, we can create the intent inside the function, by calling T::class.javaClass.

```kotlin

	public inline fun <reified T: Activity> Context.startActivity(
	        vararg params: Pair<String, String>) {
	    val intent = Intent(this, T::class.javaClass)
	    params forEach { intent.putExtra(it.first, it.second) }
	    startActivity(intent)
    }
```

It creates an intent by getting the javaClass from the generic type, iterates over params and adds them to the intent, and starts the activity using the intent. The reified type is limited to be an Activity descendant.

##  24 Interfaces
```kotlin

	interface FlyingAnimal {
	 	fun fly()
	 }

	 class Bird : FlyingAnimal {
	     val wings: Wings = Wings()
	     override fun fly() = wings.move()
	 }
	 
	 class Bat : FlyingAnimal {
	     val wings: Wings = Wings()
	     override fun fly() = wings.move()
	 }
```

But in Kotlin we can implementation functions in the interface.

The only difference from a class is that they are stateless, so the properties that need a backing field will need to be overridden by the class. The class will be in charge of saving the state of interface properties.


```kotlin

	interface FlyingAnimal {
		val wings: Wings
		fun fly() = wings.move()
	}

	class Bird : FlyingAnimal {
		override val wings: Wings = Wings() 
	}

	class Bat : FlyingAnimal {
		override val wings: Wings = Wings() 
	}

	// Use
	val bird = Bird()
	val bat = Bat()

	bird.fly()
	bat.fly()
```

**Delegation Pattern**
```kotlin

	interface CanFly {
	    fun fly()
	}
	// 'Bird' class implements 'CanFly' by the parameter passed
	class Bird(f: CanFly) : CanFly by f

	// class 'AnimalWithWings' is an implementation of 'CanFly'
	class AnimalWithWings : CanFly {
	    val wings: Wings = Wings()
	    override fun fly() = wings.move()
	}

	// 'birdWithWings' is an instance of 'Bird' whose 'CanFly' implementation is 'AnimalWithWings'
	val birdWithWings = Bird(AnimalWithWings())
	birdWithWings.fly()
```

But now wings can be used with another animals that are not birds.

```kotlin

	class Bat : CanFly by AnimalWithWings()
	...
	val bat = Bat()
	bat.fly()
```

## 25 Generics

```kotlin

	class TypedClass<T>(parameter: T) {
		val value: T = parameter
	}
```
Use
```kotlin

	val t1 = TypedClass<String>("Hello World!")
	val t2 = TypedClass<Int>(25)
```

Infer Types

```kotlin
	
	val t1 = TypedClass("Hello World!")
	val t2 = TypedClass(25)
	val t3 = TypedClass<String?>(null) // This receiving a null reference, the type still needs to be specified because it canโt be inferred.

```

Restrictions

```kotlin

	// Not Null
	class TypedClass<T : Any>(parameter: T) { 
    	val value: T = parameter
	}

	//Only Contexts
	class TypedClass<T : Context>(parameter: T) {
		val value: T = parameter
	}
```

Generic Functions

```kotlin

	fun <T> typedFunction(item: T): List<T> {
		...
	}
```

### Kotlin Generic Helpers
**let**
It receives a function with the object caller as a parameter, and returns function returns value. 
Useful to deal with nullable objects.

_Implementation_
```kotlin
	
	inline fun <T, R> T.let(f: (T) -> R): R = f(this)
```
_Use_
```kotlin
	
	//Change this
	if (forecast != null) dataMapper.convertDayToDomain(forecast) else null
	// to this
	forecast?.let { dataMapper.convertDayToDomain(it) }
```

**with**
Receives an object, and a function that will be executed as an extension function.
Returns an object defined in the last line of the function.

_Implementation_
```kotlin

	inline fun <T, R> with(receiver: T, f: T.() -> R): R = receiver.f()
```
_Use_
```kotlin

	fun convertFromDomain(forecast: ForecastList) = with(forecast) {
		val daily = dailyForecast.map { convertDayFromDomain(id, it) }
		CityForecast(id, city, country, daily)
	}
```

**apply**
Can be used to avoid the creation of builders, because the object that calls the function can initialise itself the way it needs, and the apply function will return the same object.

_Implementation_
```kotlin
	
	inline fun <T> T.apply(f: T.() -> Unit): T { f(); return this }
```
_Use_
```kotlin

	val textView = TextView(context).apply {
		text = "Hello"
		hint = "Hint"
		textColor = android.R.color.white
	}
```

```kotlin

	//Change this
	private fun createUpDrawable() = with(DrawerArrowDrawable(toolbar.ctx)) {
		progress = 1f
		this
	}
	//to this
	private fun createUpDrawable() = DrawerArrowDrawable(toolbar.ctx).apply {
		progress = 1f
	}
#Extra

##  Extend Instrumetation Tests

```kotlin

	@Test fun modifyZipCode_changesToolbarTitle() {
        openActionBarOverflowOrOptionsMenu(activityRule.activity)
        onView(withText(R.string.settings)).perform(click())
        onView(withId(R.id.cityCode)).perform(replaceText("28830"))
        pressBack()
        onView(isAssignableFrom(Toolbar::class.java))
                .check(matches(withToolbarTitle(`is`("San Fernando de Henares (ES)"))))
    }

    private fun withToolbarTitle(textMatcher: Matcher<CharSequence>): Matcher<Any> =
            object : BoundedMatcher<Any, Toolbar>(Toolbar::class.java) {

                override fun matchesSafely(toolbar: Toolbar): Boolean {
                    return textMatcher.matches(toolbar.title)
                }

                override fun describeTo(description: Description) {
                    description.appendText("with toolbar title: ")
                    textMatcher.describeTo(description)
                }
            }
```

##  Nested Classes
Not able to access the members of the outter class.
```kotlin

	class Outer {
		private val bar: Int = 1
		class Nested {
			fun foo() = 2
		}
	}

	val demo = Outer.Nested().foo() // == 2
```
**Inner** To access to the members of the outer class,
```kotlin

	class Outer {
		private val bar: Int = 1
		inner class Inner {
			fun foo() = bar
		}
	}

	val demo = Outer().Inner().foo() // == 1
```	

##  Enum classes
```kotlin

	enum class Day {
		SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
	}
```
With parameters
```kotlin

	enum class Icon(val res: Int) {
		UP(R.drawable.ic_up),
		SEARCH(R.drawable.ic_search),
		CAST(R.drawable.ic_cast)
	}

	val searchIconRes = Icon.SEARCH.res
```
Requested by the String
```kotlin

	val search: Icon = Icon.valueOf("SEARCH")
```
Get an Array
```kotlin	

	val iconList: Array<Icon> = Icon.value
```

Obtain its name and the position
```kotlin
	
	val searchName: String = Icon.SEARCH.name
	val searchPosition: Int = Icon.SEARCH.ordinal
```

##  Sealed classes
Sealed classes are used for representing restricted class hierarchies.
The number of classes that extend a sealed class is fixed.
```kotlin

	sealed class Option<out T> {
		class Some<out T> : Option<T>()
		object None : Option<Nothing>()
	}

	val result = when (option) {
		is Option.Some<*> -> "Contains a value"
		is Option.None -> "Empty"
	}
```

##  Exceptions
In Kotlin, all exceptions implement Throwable, have a message and are unchecked.
To be unchecked allow us not to use try/catch.
Both _try_ and _throw_ can beassigned to variables.

```kotlin
	
	val s = when(x){
		is Int -> "Int instance"
		is String -> "String instance"
		else -> throw UnsupportedOperationException("Not valid type")
	}
	// or
	val s = try { x as String } catch(e: ClassCastException) { null }
```